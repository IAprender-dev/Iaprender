import { Router } from 'express';
import { SecretsManager } from '../config/secrets.js';
import { storage } from '../storage.js';
import jwt from 'jsonwebtoken';
import crypto from 'crypto';
import { CognitoAdminAuth } from '../services/CognitoAdminAuth.js';

const router = Router();

/**
 * Endpoint para login com interface direta usando AWS Cognito
 */
router.post('/hybrid-login', async (req, res) => {
  try {
    const { email, password } = req.body;

    if (!email || !password) {
      return res.status(400).json({
        success: false,
        error: 'Email e senha s√£o obrigat√≥rios',
      });
    }

    console.log(`üîê Tentativa de login h√≠brido para: ${email}`);

    // Primeiro, tentar autenticar no AWS Cognito
    let cognitoUser = null;
    try {
      const cognitoAuth = new CognitoAdminAuth();
      const authResult = await cognitoAuth.authenticate(email, password);
      
      if (authResult.success && authResult.user) {
        cognitoUser = authResult.user;
        console.log(`‚úÖ Usu√°rio autenticado no Cognito: ${email}`);
      }
    } catch (cognitoError) {
      console.log(`‚ö†Ô∏è Falha na autentica√ß√£o Cognito para ${email}:`, cognitoError);
      // Continuar com valida√ß√£o local se Cognito falhar
    }

    // Se n√£o conseguiu autenticar no Cognito, verificar no banco local
    let localUser = await storage.getUserByEmail(email);
    
    if (!localUser && !cognitoUser) {
      console.log(`‚ùå Usu√°rio n√£o encontrado no Cognito nem no banco local: ${email}`);
      return res.status(404).json({
        success: false,
        error: 'Usu√°rio n√£o encontrado no sistema',
      });
    }

    // Se temos usu√°rio do Cognito mas n√£o no banco local, vamos sincronizar
    if (cognitoUser && !localUser) {
      console.log(`üîÑ Sincronizando usu√°rio do Cognito para o banco local: ${email}`);
      
      try {
        // Criar usu√°rio local baseado nos dados do Cognito
        const insertUserData = {
          cognitoSub: cognitoUser.sub || `cognito-${email}`,
          email: cognitoUser.email,
          nome: cognitoUser.name || cognitoUser.email.split('@')[0],
          tipoUsuario: mapCognitoGroupsToUserType(cognitoUser.groups || []),
          status: cognitoUser.enabled ? 'active' : 'inactive',
          empresaId: 12, // Empresa padr√£o para desenvolvimento
        };

        localUser = await storage.createUser(insertUserData);
        console.log(`‚úÖ Usu√°rio sincronizado com sucesso: ${email}`);
      } catch (syncError) {
        console.error(`‚ùå Erro ao sincronizar usu√°rio do Cognito:`, syncError);
        // Se falhar a sincroniza√ß√£o, usar dados do Cognito temporariamente
        localUser = {
          id: Date.now(), // ID tempor√°rio
          email: cognitoUser.email,
          nome: cognitoUser.name || cognitoUser.email.split('@')[0],
          tipoUsuario: mapCognitoGroupsToUserType(cognitoUser.groups || []),
          status: cognitoUser.enabled ? 'active' : 'inactive',
          empresaId: 12,
        };
      }
    }

    // Se n√£o autenticou no Cognito, validar senha local
    if (!cognitoUser) {
      const isValidPassword = await validatePassword(password, localUser.email);
      
      if (!isValidPassword) {
        console.log(`‚ùå Senha incorreta para: ${email}`);
        return res.status(401).json({
          success: false,
          error: 'Credenciais inv√°lidas',
        });
      }
    }

    // Criar token JWT compat√≠vel com Cognito
    const jwtToken = jwt.sign(
      {
        sub: localUser.id?.toString() || Date.now().toString(),
        email: localUser.email,
        name: localUser.nome,
        given_name: localUser.nome?.split(' ')[0],
        family_name: localUser.nome?.split(' ').slice(1).join(' '),
        'cognito:username': localUser.email,
        'cognito:groups': [mapUserTypeToGroup(localUser.tipoUsuario)],
        'custom:empresa_id': localUser.empresaId?.toString(),
        'custom:tipo_usuario': localUser.tipoUsuario,
        email_verified: localUser.status === 'active',
        aud: process.env.AWS_COGNITO_CLIENT_ID || 'test-client-id',
        iss: `https://cognito-idp.us-east-1.amazonaws.com/${process.env.AWS_COGNITO_USER_POOL_ID || 'test-pool-id'}`,
        token_use: 'id',
        auth_time: Math.floor(Date.now() / 1000),
        iat: Math.floor(Date.now() / 1000),
      },
      process.env.JWT_SECRET || 'test_secret_key_iaprender_2025',
      { 
        expiresIn: '24h',
        algorithm: 'HS256' // Simulando o formato do Cognito
      }
    );

    console.log(`‚úÖ Login h√≠brido bem-sucedido para: ${email}`);

    res.json({
      success: true,
      message: 'Login realizado com sucesso',
      token: jwtToken,
      user: {
        id: localUser.id,
        email: localUser.email,
        nome: localUser.nome,
        role: localUser.role || mapUserTypeToRole(localUser.tipoUsuario || 'student'),
        tipo_usuario: localUser.tipoUsuario,
        status: localUser.status,
        empresa_id: localUser.empresaId,
      },
    });

  } catch (error: any) {
    console.error('‚ùå Erro no login h√≠brido:', error);
    res.status(500).json({
      success: false,
      error: 'Erro interno do servidor',
    });
  }
});

/**
 * Valida√ß√£o de senha simples para desenvolvimento
 */
async function validatePassword(password: string, email: string): Promise<boolean> {
  // Para desenvolvimento, aceitar senhas espec√≠ficas baseadas no email
  const testPasswords = {
    'admin@example.com': 'AdminPass123!',
    'gestor@example.com': 'GestorPass123!',
    'diretor@example.com': 'DiretorPass123!',
    'professor@example.com': 'ProfessorPass123!',
    'aluno@example.com': 'AlunoPass123!',
  };

  // Verificar se √© uma senha de teste
  if (testPasswords[email as keyof typeof testPasswords] === password) {
    return true;
  }

  // Para outros emails, aceitar uma senha padr√£o para desenvolvimento
  if (password === 'dev123456' || password === 'iaprender2025') {
    return true;
  }

  return false;
}

/**
 * Mapeia grupos do Cognito para tipos de usu√°rio
 */
function mapCognitoGroupsToUserType(groups: string[]): string {
  if (!groups || groups.length === 0) return 'student';
  
  const groupMap: { [key: string]: string } = {
    'Admin': 'admin',
    'AdminMaster': 'admin',
    'Gestores': 'municipal_manager',
    'GestorMunicipal': 'municipal_manager',
    'Diretores': 'school_director',
    'Diretor': 'school_director',
    'Professores': 'teacher',
    'Professor': 'teacher',
    'Alunos': 'student',
    'Aluno': 'student',
  };

  // Retornar o primeiro grupo mapeado encontrado
  for (const group of groups) {
    if (groupMap[group]) {
      return groupMap[group];
    }
  }

  return 'student'; // Default
}

/**
 * Mapeia tipos de usu√°rio para grupos do Cognito
 */
function mapUserTypeToGroup(userType: string): string {
  const typeMap: { [key: string]: string } = {
    'admin': 'Admin',
    'municipal_manager': 'Gestores',
    'school_director': 'Diretores', 
    'teacher': 'Professores',
    'student': 'Alunos',
  };

  return typeMap[userType] || 'Alunos';
}

/**
 * Mapeia tipos de usu√°rio para roles
 */
function mapUserTypeToRole(userType: string): string {
  const typeMap: { [key: string]: string } = {
    'admin': 'admin',
    'municipal_manager': 'municipal_manager',
    'school_director': 'school_director',
    'teacher': 'teacher',
    'student': 'student',
  };

  return typeMap[userType] || 'student';
}

/**
 * Endpoint para verificar se o login h√≠brido est√° dispon√≠vel
 */
router.get('/hybrid-status', async (req, res) => {
  try {
    res.json({
      success: true,
      configured: true,
      method: 'HYBRID_PASSWORD',
      available: true,
      description: 'Login direto com valida√ß√£o local para desenvolvimento',
    });
  } catch (error: any) {
    console.error('‚ùå Erro ao verificar status h√≠brido:', error);
    res.status(500).json({
      success: false,
      error: 'Erro ao verificar configura√ß√£o',
    });
  }
});

export default router;